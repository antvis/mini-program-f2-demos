function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Util = require('../util/common');
var Helper = require('./helper');
var Interaction = require('./base');
var Chart = require('../chart/chart');
var DAY_TIMESTAMPS = 86400000;

var Pan = function (_Interaction) {
  _inherits(Pan, _Interaction);

  Pan.prototype.getDefaultCfg = function getDefaultCfg() {
    var defaultCfg = _Interaction.prototype.getDefaultCfg.call(this);
    return Util.mix({}, defaultCfg, {
      startEvent: 'panstart',
      processingEvent: 'panmove',
      endEvent: 'panend',
      resetEvent: 'touchend',
      mode: 'x', // 方向，可取值 x、y、xy
      panThreshold: 10, // Minimal pan distance required before recognizing
      pressThreshold: 9, // Minimal movement that is allowed while pressing
      pressTime: 251, // Minimal press time in ms
      currentDeltaX: null,
      currentDeltaY: null,
      panning: false,
      limitRange: {}, // 限制范围
      _timestamp: 0
    });
  };

  function Pan(cfg, chart) {
    _classCallCheck(this, Pan);

    var _this = _possibleConstructorReturn(this, _Interaction.call(this, cfg, chart));

    var hammer = _this.hammer,
        panThreshold = _this.panThreshold,
        pressThreshold = _this.pressThreshold,
        pressTime = _this.pressTime;

    hammer.get('pan').set({
      threshold: panThreshold
    });
    chart.set('limitInPlot', true);

    var tooltipController = chart.get('tooltipController');
    if (tooltipController.enable) {
      // 用户未关闭 tooltip
      chart.tooltip(false);
      hammer.get('press').set({
        threshold: pressThreshold,
        time: pressTime
      });
      hammer.on('press', Util.wrapBehavior(_this, '_handlePress'));
    }
    return _this;
  }

  Pan.prototype.start = function start(e) {
    if (this.pressed) return;
    this.currentDeltaX = 0;
    this.currentDeltaY = 0;
    this._handlePan(e);
  };

  Pan.prototype.process = function process(e) {
    if (this.pressed) return;
    this._handlePan(e);
  };

  Pan.prototype.end = function end() {
    if (this.pressed) return;

    this.currentDeltaX = null;
    this.currentDeltaY = null;
  };

  Pan.prototype.reset = function reset() {
    var self = this;
    self.pressed = false;
    self.chart.hideTooltip();
    self.chart.tooltip(false);
  };

  Pan.prototype._handlePress = function _handlePress(e) {
    this.pressed = true;
    var center = e.center;
    this.chart.tooltip(true);
    this.chart.showTooltip(center);
  };

  Pan.prototype._handlePan = function _handlePan(e) {
    var currentDeltaX = this.currentDeltaX,
        currentDeltaY = this.currentDeltaY;

    if (currentDeltaX !== null && currentDeltaY !== null) {
      this.panning = true;
      var deltaX = e.deltaX - currentDeltaX;
      var deltaY = e.deltaY - currentDeltaY;
      this.currentDeltaX = e.deltaX;
      this.currentDeltaY = e.deltaY;

      var lastTimestamp = this._timestamp;
      var now = +new Date();
      if (now - lastTimestamp > 16) {
        this._doPan(deltaX, deltaY);
        this._timestamp = now;
      }
    }
  };

  Pan.prototype._doPan = function _doPan(deltaX, deltaY) {
    var self = this;
    var mode = self.mode,
        chart = self.chart;

    var coord = chart.get('coord');
    var start = coord.start,
        end = coord.end;

    if (Helper.directionEnabled(mode, 'x') && deltaX !== 0) {
      var xScale = chart.getXScale();
      var coordWidth = end.x - start.x; // 绘图区域宽度

      if (xScale.isCategory) {
        // 横轴为分类类型
        self._panCatScale(xScale, deltaX, coordWidth);
      } else if (xScale.isLinear) {
        self._panLinearScale(xScale, deltaX, coordWidth, 'x');
      }
    }

    if (Helper.directionEnabled(mode, 'y') && deltaY !== 0) {
      var coordHeight = start.y - end.y; // 绘图区域高度
      var yScales = chart.getYScales();
      Util.each(yScales, function (yScale) {
        yScale.isLinear && self._panLinearScale(yScale, deltaY, coordHeight, 'y');
      });
    }
    chart.repaint();
  };

  Pan.prototype._panLinearScale = function _panLinearScale(scale, delta, range, flag) {
    var field = scale.field,
        min = scale.min,
        max = scale.max;


    var chart = this.chart;
    var ratio = delta / range;
    var panValue = ratio * (max - min);
    var newMax = flag === 'x' ? max - panValue : max + panValue;
    var newMin = flag === 'x' ? min - panValue : min + panValue;

    var limitRange = this.limitRange;
    if (limitRange[field] && limitRange[field].min && newMin <= limitRange[field].min) {
      newMin = limitRange[field].min;
      newMax = max - min + newMin;
    }
    if (limitRange[field] && limitRange[field].max && newMax >= limitRange[field].max) {
      newMax = limitRange[field].max;
      newMin = newMax - (max - min);
    }
    var colDef = Helper.getColDef(chart, field);
    chart.scale(field, Util.mix({}, colDef, {
      min: newMin,
      max: newMax,
      nice: false
    }));
  };

  Pan.prototype._panCatScale = function _panCatScale(scale, delta, range) {
    var chart = this.chart;
    var type = scale.type,
        field = scale.field,
        values = scale.values,
        ticks = scale.ticks;

    var colDef = Helper.getColDef(chart, field);

    if (!this.limitRange[field] || chart.get('dataChanged')) {
      // 缓存原始数据
      var data = chart.get('data');
      var _originValues = [];
      data.map(function (obj) {
        var value = obj[field];
        if (type === 'timeCat') {
          value = scale._toTimeStamp(value);
        }
        if (_originValues.indexOf(value) === -1) {
          _originValues.push(value);
        }
        return obj;
      });
      this.limitRange[field] = _originValues;
    }

    var originValues = this.limitRange[field];
    var ratio = delta / range;
    var valueLength = values.length;
    var deltaCount = Math.max(1, Math.abs(parseInt(ratio * valueLength))); // 变动的个数

    var firstIndex = originValues.indexOf(values[0]);
    var lastIndex = originValues.indexOf(values[valueLength - 1]);
    if (delta > 0 && firstIndex >= 0) {
      // 右移
      for (var i = 0; i < deltaCount && firstIndex > 0; i++) {
        firstIndex -= 1;
        lastIndex -= 1;
      }
      var newValues = originValues.slice(firstIndex, lastIndex + 1);
      var newTicks = null;
      if (type === 'timeCat') {
        var tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;
        for (var _i = ticks[0] - tickGap; _i >= newValues[0]; _i -= tickGap) {
          ticks.unshift(_i);
        }
        newTicks = ticks;
      }

      chart.scale(field, Util.mix({}, colDef, {
        values: newValues,
        ticks: newTicks
      }));
    } else if (delta < 0 && lastIndex <= originValues.length - 1) {
      // 左移
      for (var _i2 = 0; _i2 < deltaCount && lastIndex < originValues.length - 1; _i2++) {
        firstIndex += 1;
        lastIndex += 1;
      }
      var _newValues = originValues.slice(firstIndex, lastIndex + 1);

      var _newTicks = null;
      if (type === 'timeCat') {
        var _tickGap = ticks.length > 2 ? ticks[1] - ticks[0] : DAY_TIMESTAMPS;
        for (var _i3 = ticks[ticks.length - 1] + _tickGap; _i3 <= _newValues[_newValues.length - 1]; _i3 += _tickGap) {
          ticks.push(_i3);
        }
        _newTicks = ticks;
      }

      chart.scale(field, Util.mix({}, colDef, {
        values: _newValues,
        ticks: _newTicks
      }));
    }
  };

  return Pan;
}(Interaction);

Chart.registerInteraction('pan', Pan);
module.exports = Pan;