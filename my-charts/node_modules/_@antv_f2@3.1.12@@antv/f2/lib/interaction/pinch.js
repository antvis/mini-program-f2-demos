function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Util = require('../util/common');
var Helper = require('./helper');
var Interaction = require('./base');
var Chart = require('../chart/chart');

var Pinch = function (_Interaction) {
  _inherits(Pinch, _Interaction);

  Pinch.prototype.getDefaultCfg = function getDefaultCfg() {
    var defaultCfg = _Interaction.prototype.getDefaultCfg.call(this);
    return Util.mix({}, defaultCfg, {
      startEvent: 'pinchstart',
      processingEvent: 'pinch',
      endEvent: 'pinchend',
      resetEvent: 'touchend',
      pressThreshold: 9, // Minimal movement that is allowed while pressing
      pressTime: 251, // Minimal press time in ms
      mode: 'x', // 方向，可取值 x、y、xy
      currentPinchScaling: null, // 当前
      originValues: null, // 保存分类度量的原始 values
      minScale: null,
      maxScale: null,
      _timestamp: 0
    });
  };

  function Pinch(cfg, chart) {
    _classCallCheck(this, Pinch);

    var _this = _possibleConstructorReturn(this, _Interaction.call(this, cfg, chart));

    var hammer = _this.hammer,
        pressThreshold = _this.pressThreshold,
        pressTime = _this.pressTime;

    hammer.get('pinch').set({ // open pinch recognizer
      enable: true
    });
    _this._originRange = {};
    chart.set('limitInPlot', true);

    var tooltipController = chart.get('tooltipController');
    if (tooltipController.enable) {
      // 用户未关闭 tooltip
      chart.tooltip(false);
      hammer.get('press').set({
        threshold: pressThreshold,
        time: pressTime
      });
      hammer.on('press', Util.wrapBehavior(_this, '_handlePress'));
    }
    return _this;
  }

  Pinch.prototype.start = function start() {
    if (this.pressed) return;
    this.currentPinchScaling = 1;
  };

  Pinch.prototype.process = function process(e) {
    if (this.pressed) return;
    this._handlePinch(e);
  };

  Pinch.prototype.end = function end(e) {
    if (this.pressed) return;
    this._handlePinch(e);
    this.currentPinchScaling = null; // reset
  };

  Pinch.prototype.reset = function reset() {
    var self = this;
    self.pressed = false;
    self.chart.hideTooltip();
    self.chart.tooltip(false);
  };

  Pinch.prototype._handlePress = function _handlePress(e) {
    this.pressed = true;
    var center = e.center;
    this.chart.tooltip(true);
    this.chart.showTooltip(center);
  };

  Pinch.prototype._handlePinch = function _handlePinch(e) {
    var currentPinchScaling = this.currentPinchScaling;
    var diff = 1 / currentPinchScaling * e.scale;
    var rect = e.target.getBoundingClientRect();
    var offsetX = e.center.x - rect.left;
    var offsetY = e.center.y - rect.top;
    var center = {
      x: offsetX,
      y: offsetY
    };

    // fingers position difference
    var x = Math.abs(e.pointers[0].clientX - e.pointers[1].clientX);
    var y = Math.abs(e.pointers[0].clientY - e.pointers[1].clientY);

    // diagonal fingers will change both (xy) axes
    var p = x / y;
    var xy = void 0;
    if (p > 0.3 && p < 1.7) {
      xy = 'xy';
    } else if (x > y) {
      xy = 'x';
    } else {
      xy = 'y';
    }
    var lastTimestamp = this._timestamp;
    var now = +new Date();
    if (now - lastTimestamp > 16) {
      this._doZoom(diff, center, xy);
      this._timestamp = now;
    }

    // Keep track of overall scale
    this.currentPinchScaling = e.scale;
  };

  Pinch.prototype._doZoom = function _doZoom(diff, center, whichAxes) {
    var self = this;
    var mode = self.mode;
    var chart = self.chart;
    // Which axe should be modified when figers were used.
    var _whichAxes = void 0;
    if (mode === 'xy' && whichAxes !== undefined) {
      // based on fingers positions
      _whichAxes = whichAxes;
    } else {
      _whichAxes = 'xy';
    }

    if (Helper.directionEnabled(mode, 'x') && Helper.directionEnabled(_whichAxes, 'x')) {
      // x
      var xScale = chart.getXScale();
      if (xScale.isCategory) {
        // 横轴为分类类型
        self._zoomCatScale(xScale, diff, center);
      } else if (xScale.isLinear) {
        self._zoomLinearScale(xScale, diff, center, 'x');
      }
    }

    if (Helper.directionEnabled(mode, 'y') && Helper.directionEnabled(_whichAxes, 'y')) {
      // y
      var yScales = chart.getYScales();
      Util.each(yScales, function (yScale) {
        yScale.isLinear && self._zoomLinearScale(yScale, diff, center, 'y');
      });
    }

    chart.repaint();
  };

  Pinch.prototype._zoomLinearScale = function _zoomLinearScale(scale, zoom, center, flag) {
    var type = scale.type;
    if (type !== 'linear') return;
    var field = scale.field;
    var chart = this.chart;
    var min = scale.min,
        max = scale.max;

    var valueRange = max - min;
    if (!this._originRange[field] || chart.get('dataChanged')) {
      this._originRange[field] = valueRange;
    }

    var coord = chart.get('coord');
    var colDef = Helper.getColDef(chart, field);

    var newDiff = valueRange * (zoom - 1);
    if (this.minScale && zoom < 1) {
      // 缩小
      var maxRange = this._originRange[field] / this.minScale;
      newDiff = Math.max(valueRange - maxRange, newDiff);
    }

    if (this.maxScale && zoom >= 1) {
      // 放大
      var minRange = this._originRange[field] / this.maxScale;
      newDiff = Math.min(valueRange - minRange, newDiff);
    }

    var offsetPoint = coord.invertPoint(center);
    var percent = flag === 'x' ? offsetPoint.x : offsetPoint.y;
    var minDelta = newDiff * percent;
    var maxDelta = newDiff * (1 - percent);
    var newMax = max - maxDelta;
    var newMin = min + minDelta;

    chart.scale(field, Util.mix({}, colDef, {
      min: newMin,
      max: newMax,
      nice: false
    }));
  };

  Pinch.prototype._zoomCatScale = function _zoomCatScale(scale, zoom, center) {
    var type = scale.type,
        field = scale.field,
        values = scale.values;

    var chart = this.chart;
    var coord = chart.get('coord');
    var colDef = Helper.getColDef(chart, field);

    if (!this.originValues || chart.get('dataChanged')) {
      var data = chart.get('data');
      var _originValues = [];
      data.map(function (obj) {
        var value = obj[field];
        if (type === 'timeCat') {
          value = scale._toTimeStamp(value);
        }
        if (_originValues.indexOf(value) === -1) {
          _originValues.push(value);
        }
        return obj;
      });
      this.originValues = _originValues;
      this.originTicks = scale.ticks;
    }

    var originTicks = this.originTicks;
    var originValues = this.originValues;
    var originValuesLen = originValues.length;
    var maxScale = this.maxScale || 4;
    var minScale = this.minScale || 1;
    var minCount = originValuesLen / maxScale;
    var maxCount = originValuesLen / minScale;

    var valuesLength = values.length;
    var offsetPoint = coord.invertPoint(center);
    var percent = offsetPoint.x;
    var deltaCount = parseInt(valuesLength * Math.abs(zoom - 1));
    var minDelta = parseInt(deltaCount * percent);
    var maxDelta = deltaCount - minDelta;

    if (zoom >= 1 && valuesLength >= minCount) {
      // 放大
      var newValues = values.slice(minDelta, valuesLength - maxDelta);
      chart.scale(field, Util.mix({}, colDef, {
        values: newValues,
        ticks: originTicks
      }));
    } else if (zoom < 1 && valuesLength <= maxCount) {
      // 缩小
      var firstIndex = originValues.indexOf(values[0]);
      var lastIndex = originValues.indexOf(values[valuesLength - 1]);
      var minIndex = Math.max(0, firstIndex - minDelta);
      var maxIndex = Math.min(lastIndex + maxDelta, originValuesLen);
      var _newValues = originValues.slice(minIndex, maxIndex);
      chart.scale(field, Util.mix({}, colDef, {
        values: _newValues,
        ticks: originTicks
      }));
    }
  };

  return Pinch;
}(Interaction);

Chart.registerInteraction('pinch', Pinch);
module.exports = Pinch;