function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Hammer = require('hammerjs'); // http://hammerjs.github.io/
var Util = require('../util/common');

var defaultOptions = {
  useCalculate: true, // 计算事件触发位置，对应的图表的数据. 关闭返回null
  useOffset: false // 计算数据是否需要计算图表相对页面偏移的坐标
};

var GestureController = function () {
  function GestureController(_ref) {
    var dom = _ref.dom,
        gesture = _ref.gesture,
        options = _ref.options,
        chart = _ref.chart,
        hammerOptions = _ref.hammerOptions;

    _classCallCheck(this, GestureController);

    this.Hammer = Hammer;
    this.hammer = new Hammer(dom, hammerOptions);
    this.dom = dom;
    this.gesture = gesture;
    this.options = Util.deepMix({}, defaultOptions, options);
    this.hammerOptions = hammerOptions;
    this.chart = chart;
    this._unbindEvent = {}; // 没有绑定事件
    if (!options) {
      this.hammerOptionsHack(gesture, this.hammer);
    }
  }
  // hammer默认配置把多指事件swipe 和 pinch 关闭。 如果没有自定义optionas为空则设置


  GestureController.prototype.hammerOptionsHack = function hammerOptionsHack(gesture, hammer) {
    for (var key in gesture) {
      if (key.indexOf('swipe') !== -1 && hammer.get('swipe')) {
        hammer.get('swipe').set({ enable: true });
      }

      if (key.indexOf('pinch') !== -1 && hammer.get('pinch')) {
        hammer.get('pinch').set({ enable: true });
      }
    }
  };
  // 等geom绘制完再绑定事件


  GestureController.prototype.bindEvents = function bindEvents() {
    var _this = this;

    var gesture = this.gesture,
        hammer = this.hammer,
        dom = this.dom;
    var useCalculate = this.options.useCalculate;

    if (!hammer) {
      return;
    }

    var _loop = function _loop(key) {
      // 基础的事件，hammer没提供，手动绑定。
      if (['touchstart', 'touchmove', 'touchend'].indexOf(key) !== -1) {
        var bindEvent = function bindEvent(event) {
          var records = useCalculate ? _this.getEventPostionRecords(event, true) : null;
          gesture[key](records, event);
        };
        Util.addEventListener(dom, key, bindEvent);
        _this._unbindEvent[key] = bindEvent;
      } else {
        hammer.on(key, function (event) {
          var records = useCalculate ? _this.getEventPostionRecords(event, false) : null;
          gesture[key](records, event);
        });
      }
    };

    for (var key in gesture) {
      _loop(key);
    }
  };
  // 获取发生手势事件对应的数据


  GestureController.prototype.getEventPostionRecords = function getEventPostionRecords(event, _isOrigin) {
    var useOffset = this.options.useOffset;

    var canvasDom = this.chart.get('canvas').get('el');
    var x = void 0;
    var y = void 0;
    // 原生的事件
    if (_isOrigin) {
      var positionSource = event.targetTouches.length > 0 ? event.targetTouches[0] : event.changedTouches[0];
      if (useOffset) {
        x = positionSource.clientX - canvasDom.offsetLeft;
        y = positionSource.clientY - canvasDom.offsetTop;
      } else {
        x = positionSource.clientX;
        y = positionSource.clientY;
      }
    } else {
      if (useOffset) {
        x = event.center.x - canvasDom.offsetLeft;
        y = event.center.y - canvasDom.offsetTop;
      } else {
        x = event.center.x;
        y = event.center.y;
      }
    }
    return this.chart.getSnapRecords({ x: x, y: y });
  };

  GestureController.prototype.destroy = function destroy() {
    this.hammer.destroy();
    for (var key in this._unbindEvent) {
      var event = this._unbindEvent[key];
      Util.removeEventListener(this.dom, key, event);
    }
  };

  return GestureController;
}();

module.exports = {
  init: function init(chart) {
    // 在chart对象上增加一个方法，用于插件传参数。
    chart.pluginGesture = function (_ref2) {
      var gesture = _ref2.gesture,
          options = _ref2.options,
          hammerOptions = _ref2.hammerOptions;

      var canvasDom = chart.get('canvas').get('el');
      var gestureController = new GestureController({ dom: canvasDom, gesture: gesture, options: options, hammerOptions: hammerOptions, chart: chart });
      gestureController.bindEvents();
      chart.set('gestureController', gestureController);
      return gestureController;
    };
  },
  clear: function clear(chart) {
    var gestureController = chart.get('gestureController');
    gestureController && gestureController.destroy();
  }
};