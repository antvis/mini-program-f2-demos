function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Util = require('../../util/common');
var GuideBase = require('./base');

var Tag = function (_GuideBase) {
  _inherits(Tag, _GuideBase);

  function Tag() {
    _classCallCheck(this, Tag);

    return _possibleConstructorReturn(this, _GuideBase.apply(this, arguments));
  }

  Tag.prototype._initDefaultCfg = function _initDefaultCfg() {
    this.type = 'tag';
    this.position = null;
    this.content = null;
    this.direct = 'auto'; // 默认自动计算，如果用户设置了就按照用户设置的渲染
    this.offsetX = 0;
    this.offsetY = 0;
    this.side = 4; //  三角标的边长
    this.background = {
      padding: 5, // tag 内边距
      radius: 2, // tag 圆角
      fill: '#1890FF' // tag 背景色
    };
    this.textStyle = {
      fontSize: 12,
      fill: '#fff',
      textAlign: 'center',
      textBaseline: 'middle'
    };
    this.withPoint = true;
    this.pointStyle = {
      fill: '#1890FF',
      r: 3,
      lineWidth: 1,
      stroke: '#fff'
    };
  };

  Tag.prototype._getDirect = function _getDirect(container, point, tagWidth, tagHeight) {
    var direct = this.direct;
    if (direct === 'auto') {
      // 自动计算
      var side = this.side;
      var canvas = container.get('canvas');
      var clientWidth = canvas.getWidth();
      var clientHeight = canvas.getHeight();
      var x = point.x,
          y = point.y;


      var vertical = 't';
      var horizontal = 'l';

      if (y - side - tagHeight < 0) {
        vertical = 'b';
      }

      if (vertical === 'b') {
        if (y + side + tagHeight > clientHeight) {
          vertical = 't';
        }
      }

      var diff = vertical === 'c' ? side : 0;
      if (x - diff - tagWidth < 0) {
        horizontal = 'r';
      }
      if (horizontal === 'r') {
        var _diff = vertical === 'c' ? side : 0;
        if (x + _diff + tagWidth > clientWidth) {
          horizontal = 'l';
        }
      }
      direct = vertical + horizontal;
      this.direct = direct;
    }

    return direct;
  };

  Tag.prototype.render = function render(coord, container) {
    var position = this.parsePoint(coord, this.position);
    var content = this.content,
        background = this.background,
        textStyle = this.textStyle;


    var wrapperContainer = container.addGroup({
      className: 'guide-tag'
    });

    if (this.withPoint) {
      wrapperContainer.addShape('Circle', {
        className: 'guide-tag-point',
        attrs: Util.mix({
          x: position.x,
          y: position.y
        }, this.pointStyle)
      });
    }

    var tagContainer = wrapperContainer.addGroup();
    // 绘制文本
    var tagText = tagContainer.addShape('text', {
      className: 'guide-tag-text',
      zIndex: 1,
      attrs: Util.mix({
        x: 0,
        y: 0,
        text: content
      }, textStyle)
    });

    // 绘制背景框
    var textBBox = tagText.getBBox();
    var padding = Util.parsePadding(background.padding);
    var tagWidth = textBBox.width + padding[1] + padding[3];
    var tagHeight = textBBox.height + padding[0] + padding[2];
    var yMin = textBBox.minY - padding[0];
    var xMin = textBBox.minX - padding[3];
    var tagBg = tagContainer.addShape('rect', {
      className: 'guide-tag-bg',
      zIndex: -1,
      attrs: Util.mix({
        x: xMin,
        y: yMin,
        width: tagWidth,
        height: tagHeight
      }, background)
    });
    var direct = this._getDirect(container, position, tagWidth, tagHeight);
    var side = this.side;
    var x = position.x + this.offsetX;
    var y = position.y + this.offsetY;
    var arrowPoints = void 0;
    var radius = Util.parsePadding(background.radius);
    if (direct === 'tl') {
      arrowPoints = [{ x: tagWidth - side + xMin, y: tagHeight + yMin - 1 }, // 这个 1 是为了防止出现白边
      { x: tagWidth + xMin, y: tagHeight + yMin - 1 }, { x: tagWidth + xMin, y: tagHeight + side + yMin }];
      radius[2] = 0;
      x = x - tagWidth;
      y = y - side - tagHeight;
    } else if (direct === 'cl') {
      arrowPoints = [{ x: tagWidth + xMin - 1, y: (tagHeight - side) / 2 + yMin }, { x: tagWidth + xMin - 1, y: (tagHeight + side) / 2 + yMin }, { x: tagWidth + side + xMin, y: tagHeight / 2 + yMin }];

      x = x - tagWidth - side;
      y = y - tagHeight / 2;
    } else if (direct === 'bl') {
      arrowPoints = [{ x: tagWidth + xMin, y: -side + yMin }, { x: tagWidth - side + xMin, y: yMin + 1 }, { x: tagWidth + xMin, y: yMin + 1 }];
      radius[1] = 0;

      x = x - tagWidth;
      y = y + side;
    } else if (direct === 'bc') {
      arrowPoints = [{ x: tagWidth / 2 + xMin, y: -side + yMin }, { x: (tagWidth - side) / 2 + xMin, y: yMin + 1 }, { x: (tagWidth + side) / 2 + xMin, y: yMin + 1 }];
      x = x - tagWidth / 2;
      y = y + side;
    } else if (direct === 'br') {
      arrowPoints = [{ x: xMin, y: -side + yMin }, { x: xMin, y: yMin + 1 }, { x: side + xMin, y: yMin + 1 }];
      radius[0] = 0;
      y = y + side;
    } else if (direct === 'cr') {
      arrowPoints = [{ x: -side + xMin, y: tagHeight / 2 + yMin }, { x: xMin + 1, y: (tagHeight - side) / 2 + yMin }, { x: xMin + 1, y: (tagHeight + side) / 2 + yMin }];
      x = x + side;
      y = y - tagHeight / 2;
    } else if (direct === 'tr') {
      arrowPoints = [{ x: 0 + xMin, y: tagHeight + side + yMin }, { x: 0 + xMin, y: tagHeight + yMin - 1 }, { x: side + xMin, y: tagHeight + yMin - 1 }];
      radius[3] = 0;

      y = y - tagHeight - side;
    } else if (direct === 'tc') {
      arrowPoints = [{ x: (tagWidth - side) / 2 + xMin, y: tagHeight + yMin - 1 }, { x: (tagWidth + side) / 2 + xMin, y: tagHeight + yMin - 1 }, { x: tagWidth / 2 + xMin, y: tagHeight + side + yMin }];
      x = x - tagWidth / 2;
      y = y - tagHeight - side;
    }

    tagContainer.addShape('Polygon', {
      zIndex: 0,
      attrs: {
        points: arrowPoints,
        fill: background.fill
      }
    });

    tagBg.attr('radius', radius);
    tagContainer.moveTo(x - xMin, y - yMin);
    tagContainer.sort();

    this.element = wrapperContainer;
  };

  return Tag;
}(GuideBase);

GuideBase.Tag = Tag;
module.exports = Tag;